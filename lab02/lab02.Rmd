---
title: "lab02"
author: "Nikitina Natalia"
date: '16 октября 2017 г '
output: html_document
---
ИСХОДНЫЕ ДАННЫЕ.

Установленная среда R включает в себя набор заранее сконфигурированных массивов данных. В данной лабораторной требуется использовать одну из них — датафрейм из 93 машин-новинок 1993 года. Для того, чтобы загрузить данный датафрейм, необходимо выполнить следующие команды:
```{r}
library(MASS)
data(Cars93)
```
Для того, чтобы ознакомиться со структурой и составом данных, можно выполнить команду View(Cars93) или нажать на соответствующую кнопку в RStudio.
```{r}
View(Cars93);
```

ЗАДАНИЕ 1.

1. Выполните команду summary() на полном наборе данных. Можно ли по результату выполнения сказать, сколько строк в датафрейме? Если да, напишите сколько. Если нет, то приведите другой способ.
```{r}
summary(Cars93);
nrow(Cars93); #команда, возвращающая количество строк в датафрейме
```
Вывод: по выходным данным команды summary() можно определить количество строк в датафрейме, однако для этого необходимо выполнить операцию сложения для данных команды, полученных по одному из признаков, обозначенных в датафрейме. Команда summary() служит для отображения распределения элементов датафрейма по признакам и возвращает относительные частоты вхождения элементов для каждого признака, при этом сумма всех относительных частот = количеству строк датафрейма.

Такой способ определения общего количества строк возможен, но не вполне удобен, лучше использовать команду nrow(), которая возвращает только одно значение - 93 строки.

2. Найдите среднюю цену машин с задним приводом.
```{r}
mean(subset(Cars93$Price,Cars93$DriveTrain=="Rear"));
```

3. Найдите минимальное число лошадиных сил автомобиля для 7 пассажиров. Для 6 пассажиров.
```{r}
min(subset(Cars93$Horsepower,Cars93$Passengers=="7"));
min(subset(Cars93$Horsepower,Cars93$Passengers=="6"));
```

4. Найдите машины с максимальным, минимальным и средним (медианой) расстоянием, которое машина может проехать по трассе. Вам понадобятся 2 колонки, чтобы рассчитать расстояние. Какие?
```{r}
distance <- Cars93$MPG.highway*Cars93$Fuel.tank.capacity;
car.distances <- c(max(distance),min(distance),median(distance));
car.names <- c(as.character(Cars93$Make[which(distance==max(distance))]),as.character(Cars93$Make[which(distance==min(distance))]),as.character(Cars93$Make[which(distance==median(distance))]));
car.features <- c("Maximum","Minimum","Median");
distance.df <- data.frame(Feature = car.features, Name = car.names, Distance=car.distances);
distance.df;
```
Для получения требуемых значений расстояния были использованы колонки MPG.highway (расход топлива на трассе [миля/галлон]) и Fuel.tank.capacity (объем бака [галлон]). Чтобы получить вектор расстояний в милях, значения данных колонок были умножены друг на друга.

ЗАДАНИЕ 2. 

В самом начале занятий приводился пример с фабрикой и производством автомобилей. Ниже приведён пример кода, который старается оптимизировать выпуск продукции ориентируясь на доступные ресурсы.
```{r}
factory.run <- function (o.cars=1, o.trucks=1) {
  factory <- matrix(c(40,1,60,3),nrow=2, dimnames=list(c("трудодни","сталь"),c("автомобили","грузовики")))
  warehouse <- c(1600,70) #Доступно материалов на складе
  names(warehouse) <- rownames(factory)
  reserve <- c(8,1)
  names(reserve) <- rownames(factory)
  output <- c(o.cars, o.trucks)
  names(output) <- colnames(factory)
  
  steps <- 0 # Счётчик числа шагов цикла
  repeat {
    steps <- steps + 1
    needed <- factory %*% output # Подсчитаем ресурсы, которые нам нужны для производства требуемого кол-ва машин
    message(steps)
    print(needed)
    # Если ресурсов достаточно и остаток меньше или равен резерву, то мы произвели максимум возможного.
    # Нужно прекращать
    if (all(needed <= warehouse) && all((warehouse - needed) <= reserve)) {
      break()
    }
    # Если заявка слишком большая и ресурсов недостаточно, уменьшим её на 10%
    if (all(needed > warehouse)) {
      output <- output * 0.9
      next()
    }
    # Если всё наоброт, то увеличим на 10%
    if (all(needed < warehouse)) {
      output <- output * 1.1
      next()
    }
    # Если мы потребили одного ресурса слишком много, а другого недостаточно,
    # то увеличим план на случайную величину
    output <- output * (1+runif(length(output),min=-0.1,max=0.1))
  }
  
  return(output)
}
```

1. Выполните код и запустите эту функцию factory.run().
```{r}
factory.run();
```

2.С каким входными значениями функция вызвана? Какой получился результат?

Функция была вызвана с входными параметрами по умолчанию (o.cars=1, o.trucks=1), то есть изначально необходимо было изготовить одну машину и один грузовик. Однако в результате было получено 9 автомобилей и 19 грузовиков (если точно, 9.89 и 19.97), так как данная функция служит для согласования входных параметров и доступных ресурсов (для оптимизации производства), прописанных внутри функции. Таким образом, количество производимых товаров было изменено так, чтобы потреблялось указанное количество ресурсов.

Кроме того, помимо самого результата (потраченных ресурсов и количества произведенных товаров) функцией выводятся все промежуточные шаги цикла, находящегося внутри нее.

3. Повторите вызов 4 раза. Полученные ответы отличаются от полученных ранее? Если да, почему? Если нет, почему?
```{r}
factory.run();
factory.run();
factory.run();
factory.run();
```
В результате повторных вызовов функции были получены следующие значения для машин и грузовиков соответственно:
10.45 19.67
9.99 19.88
10.11 19.9
10.68 19.47.
Видно, что, хотя тенденция сохраняется и все полученные значения мало отличаются друг от друга, но отличия всё же есть. Это связано с тем, что в работе функции присутствует элемент случайности (в случае, когда одного ресурса потреблено слишком много, а другого недостаточно план увеличивается на равномерно распределенную случайную величину, полученную с помощью функции runif()). Следует отметить, что иногда полученные различия всё же имеют вес, так как итоговое количество произведенных автомобилей в некоторых случаях отличается (9 или 10). На самом деле значения отличаются на десятые доли, но в рамках поставленной задачи важны целые числа.

4. В приведённом коде переменные steps и output находятся внутри алгоритма. Измените функцию так, чтобы она возвращала число шагов и произведённое количество машин.
```{r}
factory.run <- function (o.cars=1, o.trucks=1) {
  factory <- matrix(c(40,1,60,3),nrow=2, dimnames=list(c("трудодни","сталь"),c("автомобили","грузовики")))
  warehouse <- c(1600,70) #Доступно материалов на складе
  names(warehouse) <- rownames(factory)
  reserve <- c(8,1)
  names(reserve) <- rownames(factory)
  output <- c(o.cars, o.trucks)
  names(output) <- colnames(factory)
  
  steps <- 0 # Счётчик числа шагов цикла
  repeat {
    steps <- steps + 1
    names(steps) <- "количество шагов";
    needed <- factory %*% output # Подсчитаем ресурсы, которые нам нужны для производства требуемого кол-ва машин
    # Если ресурсов достаточно и остаток меньше или равен резерву, то мы произвели максимум возможного.
    # Нужно прекращать
    if (all(needed <= warehouse) && all((warehouse - needed) <= reserve)) {
      break()
    }
    # Если заявка слишком большая и ресурсов недостаточно, уменьшим её на 10%
    if (all(needed > warehouse)) {
      output <- output * 0.9
      next()
    }
    # Если всё наоброт, то увеличим на 10%
    if (all(needed < warehouse)) {
      output <- output * 1.1
      next()
    }
    # Если мы потребили одного ресурса слишком много, а другого недостаточно,
    # то увеличим план на случайную величину
    output <- output * (1+runif(length(output),min=-0.1,max=0.1))
  }
  
  return(list(steps,needed,output))
}
```


5. Установите план равный тридцати автомобилям и 20 грузовикам и выполните функцию.
    a. Какой получили результат?
    b. Каким получился итоговый запрос ресурсов (переменная needed)
    c. Как много итераций пришлось пройти, чтобы получить ответ (переменная steps)?
    d. Для подсчёта можно пользоваться функциями печати (print, message) или вернуть результат из функции.
```{r}
factory.run(30,20);
```
В результате выполнения функции с входными параметрами (30,20) был вновь получен тот же самый результат (10 автомобилей, 20 грузовиков). Итоговый запрос ресурсов получился равным 1597 трудодням и 69.76 тоннам стали. Для получения результата было пройдено 312 итераций.

Можно сделать вывод, что при подобной организации функции - в случае, когда указано точное количество материалов на складе и необходимо так оптимизировать производство, чтобы они были использованы по максимуму, вне зависимости от входных параметров будет получен один и тот же результат, наиболее близкий к оптимальному распределению ресурсов.
